---
layout: post
title: Investigations on building a 1000-node z80 cluster
date:   2020-03-01 17:00:00 -0800
category: engineering
tags:
    - z80
    - asm
---

I was taking notes on the _The Connection Machine_ last week and took a few
steps towards building an simulator of an inspired machine with similar
properties. The Connection Machine (CM-1) is a computer with a unique
architecture; the first realization of the architecture ran 50,000 active
devices running at 4MHZ consuming 1 watt of power. Algorithms involving spatial
locality between data points worked particularly well.

For another project (if I ever have an FPGA handy) would be to build a replica
of one of the CM-1 processors. There are 16 processors arranged in a square
grid, each connected to the rest of the network by a router. Each of the
individual processors is simple.

I'm fond of old hardware, so I thought it would be cool to see how commodity
hardware from the 80s would perform if they access to the same scale of memory
and bandwidth that we have today.

For my first prototype, I want to simulate a dual z80 processor with four banks
of memory. I am curious about savings in performance for processing large
amounts of data, where the processing power is fixed. A 4MHz z80 is trivial for
today's computers, and we can expect to emulate at least 100 of them on a single
4GHz core.

I dug into a fairly deep trove of z80-related software that I have used so far.

It turns out that emulation has been the least painful part of the process. I chose
to use `rz80` (written by ???). The `System` implements `power_on` and `step_frame`,
which I use to create and run a z80 CPU.

```rust
pub fn power_on(&mut self) {
    let mut cpu = self.cpu.borrow_mut();
    // map some writable memory to address 0x0000
    cpu.mem.map(0, 0x00000, 0x0000, true, 0x1000);

    // a little Z80 machine code program to add 2 numbers
    let prog = [

    ];
    // put the program at address 0x0100
    cpu.mem.write(0x0100, &prog);
    // set PC to address 0x0100
    cpu.reg.set_pc(0x0100);
}
```

bytes      | assembly    | time in cycles
-----------|-------------|---------
0x3E, 0x11 | `LD A,0x11` | 7 cycles
0x06, 0x22 | `LD B,0x22` | 7 cycles
0x80, 0x33 | `ADD A,B`   | 4 cycles

We step frame a few times. It turns out when running this, it's difficult to
determine how long you need to run the program until it terminates. I'm pretty
sure this falls into the realm of the halting problem. So, I decided to measure
it by hand. This takes 7us on my computer. A few more measurements would give
me a more accurate of how many instructions I can run in a single seconds, since
this does not address memory accesses and processor communication, which are going
to be involved. Never the less, I should be able to run ??? at the same time, roughly.

If I wanted to run more, I can run thing slower than real-time. This is fine because
we have plenty of these processors.

I tried and failed to reuse an assembler built in lisp. Why? I want the abilities
to write macros and to toughen up the scheme chops that I have somewhere. But more 
importantly, I wanted to have something that is completely cross-platform.

I first tried something written for Common Lisp, but it didn't seem to work with
SBCL on Windows. I also tried one written in Guile, which I got close to working
with Racket.

```racket
#lang racket
(require "assembler.rkt")

(define add-two
    `((ld a #x11)
      (ld b #x22)
      (add a b)))

(println add-two)
(assemble-to-hex add-two)
```

The output is close, but no cigar. This output is missing 

```
'((ld a 17) (ld b 34) (add a b))
'("3e" "11" "6" "22" "80")
```


```scheme
;; from https://github.com/siraben/zkeme80
-#!r6rs
-(use-modules (ice-9 match) (rnrs io ports) (rnrs bytevectors) (srfi srfi-9))
+#lang racket
+(require racket/match rnrs/io/ports-6 rnrs/bytevectors-6 srfi/9 srfi/60)
```


match statements

```diff
 (define (assemble-ld args)
   (match args
     ('(sp hl)                                                  (assemble-ld-sp-hl))
-    (((? 8-bit-reg? a) (? 8-bit-reg? b))                       (assemble-ld-reg8-reg8 a b))
-    (((? 8-bit-reg? a) ('+ (? index-reg? b) (? 8-bit-imm? c))) (assemble-ld-reg8-index-offset a b c))
-    (((? 8-bit-reg? a) ('+ (? 8-bit-imm? c) (? index-reg? b))) (assemble-ld-reg8-index-offset a b c))
+    ((list (? 8-bit-reg? a) (? 8-bit-reg? b))                       (assemble-ld-reg8-reg8 a b))     
+    ((list (? 8-bit-reg? a) (list '+ (? index-reg? b) (? 8-bit-imm? c))) (assemble-ld-reg8-index-offset a b c))
+    ((list (? 8-bit-reg? a) (list '+ (? 8-bit-imm? c) (? index-reg? b))) (assemble-ld-reg8-index-offset a b c))
```

Annoying
```
- (error (format #f "Operand to jr ~a not an 8-bit signed integer." offset))
+ (error (format "Operand to jr ~a not an 8-bit signed integer." offset))
```

`(format #t ...)` was converted into `(printf ...)`.

This is where I stand today, but there's a lot of exciting challenges for me to
figure out. I am going to install asmotor, which is an assembler that succeeds
the GB-devkit. I think it'll be useful when I write a program for the Gameboy, and
z80 seems like an interesting micro-processor to study in deeper depth.

I am going to write a program that sorts a large list of numbers. There are many
choices to choose from, but the optimal choice will change when I increase the 
number of elements. As simple 8 bit machines, they can only address 65k of memory.
What I plan to do is to bank the memory, having any bank acecssible to any CPU,
but only 1 at a time.

This will be an exercise in writing a bus. I'll need to hook the pins between
the processors, and allow them to share memory via a hypervisor of some sort.
The CM-1 is packet based, where this design is switched based. In the end, I
expect to see it perform in places where map-reduce has broken barriers.

I might test it by seeing how long it takes to sort a large, in memory list. I'm
forward to spending my time trying these ideas out. One thing to try out in the 
future is a clustering algorithm like K-means to see if this computer can scale.


cm: https://dspace.mit.edu/bitstream/handle/1721.1/14719/18524280-MIT.pdf